
Hangman.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000077a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002da  00800060  0000077a  0000080e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000016  0080033a  0080033a  00000ae8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ae8  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000048  00000000  00000000  00000b18  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000666  00000000  00000000  00000b60  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000237  00000000  00000000  000011c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000029b  00000000  00000000  000013fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000080  00000000  00000000  00001698  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001f4  00000000  00000000  00001718  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000048f  00000000  00000000  0000190c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000b0  00000000  00000000  00001d9b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	13 e0       	ldi	r17, 0x03	; 3
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e7       	ldi	r30, 0x7A	; 122
  68:	f7 e0       	ldi	r31, 0x07	; 7
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	aa 33       	cpi	r26, 0x3A	; 58
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	23 e0       	ldi	r18, 0x03	; 3
  78:	aa e3       	ldi	r26, 0x3A	; 58
  7a:	b3 e0       	ldi	r27, 0x03	; 3
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 35       	cpi	r26, 0x50	; 80
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 10 02 	call	0x420	; 0x420 <main>
  8a:	0c 94 bb 03 	jmp	0x776	; 0x776 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <US_init>:
#define US_NO_OBSTACLE -13
void US_init();
void US_trig();
void US_init()
{
	US_DDR|=(1<<US_TRIG);
  92:	b8 9a       	sbi	0x17, 0	; 23
  94:	08 95       	ret

00000096 <US_trig>:

void US_trig()
{
	//Send a 10uS pulse on trigger line
	
	US_PORT|=(1<<US_TRIG); //high
  96:	c0 9a       	sbi	0x18, 0	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  98:	85 e0       	ldi	r24, 0x05	; 5
  9a:	8a 95       	dec	r24
  9c:	f1 f7       	brne	.-4      	; 0x9a <US_trig+0x4>
	
	_delay_us(15);    //wait 15uS
	
	US_PORT&=~(1<<US_TRIG); //low
  9e:	c0 98       	cbi	0x18, 0	; 24
  a0:	08 95       	ret

000000a2 <pulse_width>:
	uint32_t i,result;      // Value goes from 0 to 65536.

	//Wait for the rising edge
	for(i=0;i<600000;i++)
	{
		if(!(US_PIN & (1<<US_ECHO)))
  a2:	b1 99       	sbic	0x16, 1	; 22
  a4:	16 c0       	rjmp	.+44     	; 0xd2 <pulse_width+0x30>
{

	uint32_t i,result;      // Value goes from 0 to 65536.

	//Wait for the rising edge
	for(i=0;i<600000;i++)
  a6:	81 e0       	ldi	r24, 0x01	; 1
  a8:	90 e0       	ldi	r25, 0x00	; 0
  aa:	a0 e0       	ldi	r26, 0x00	; 0
  ac:	b0 e0       	ldi	r27, 0x00	; 0
	{
		if(!(US_PIN & (1<<US_ECHO)))
  ae:	b1 99       	sbic	0x16, 1	; 22
  b0:	0b c0       	rjmp	.+22     	; 0xc8 <pulse_width+0x26>
{

	uint32_t i,result;      // Value goes from 0 to 65536.

	//Wait for the rising edge
	for(i=0;i<600000;i++)
  b2:	01 96       	adiw	r24, 0x01	; 1
  b4:	a1 1d       	adc	r26, r1
  b6:	b1 1d       	adc	r27, r1
  b8:	80 3c       	cpi	r24, 0xC0	; 192
  ba:	27 e2       	ldi	r18, 0x27	; 39
  bc:	92 07       	cpc	r25, r18
  be:	29 e0       	ldi	r18, 0x09	; 9
  c0:	a2 07       	cpc	r26, r18
  c2:	b1 05       	cpc	r27, r1
  c4:	a1 f7       	brne	.-24     	; 0xae <pulse_width+0xc>
  c6:	3c c0       	rjmp	.+120    	; 0x140 <pulse_width+0x9e>
		continue;      //Line is still low, so wait
		else
		break;       //High edge detected, so break.
	}

	if(i==600000)
  c8:	80 3c       	cpi	r24, 0xC0	; 192
  ca:	97 42       	sbci	r25, 0x27	; 39
  cc:	a9 40       	sbci	r26, 0x09	; 9
  ce:	b1 05       	cpc	r27, r1
  d0:	d1 f1       	breq	.+116    	; 0x146 <pulse_width+0xa4>
	
	//High Edge Found


	//Setup Timer1
	TCCR1A=0X00;
  d2:	1f bc       	out	0x2f, r1	; 47
	TCCR1B=(1<<CS11);      //Prescaler = Fcpu/8
  d4:	82 e0       	ldi	r24, 0x02	; 2
  d6:	8e bd       	out	0x2e, r24	; 46
	TCNT1=0x00;        //Again initialising the counter
  d8:	1d bc       	out	0x2d, r1	; 45
  da:	1c bc       	out	0x2c, r1	; 44
	//Counting the width of pulse.
	
	//Now wait for the falling edge
	for(i=0;i<600000;i++)
	{
		if(US_PIN & (1<<US_ECHO))
  dc:	b1 9b       	sbis	0x16, 1	; 22
  de:	20 c0       	rjmp	.+64     	; 0x120 <pulse_width+0x7e>
		{
			if(TCNT1 > 60000) break; else continue;
  e0:	8c b5       	in	r24, 0x2c	; 44
  e2:	9d b5       	in	r25, 0x2d	; 45
  e4:	81 36       	cpi	r24, 0x61	; 97
  e6:	9a 4e       	sbci	r25, 0xEA	; 234
  e8:	d8 f4       	brcc	.+54     	; 0x120 <pulse_width+0x7e>
	TCNT1=0x00;        //Again initialising the counter

	//Counting the width of pulse.
	
	//Now wait for the falling edge
	for(i=0;i<600000;i++)
  ea:	81 e0       	ldi	r24, 0x01	; 1
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	a0 e0       	ldi	r26, 0x00	; 0
  f0:	b0 e0       	ldi	r27, 0x00	; 0
	{
		if(US_PIN & (1<<US_ECHO))
  f2:	b1 9b       	sbis	0x16, 1	; 22
  f4:	10 c0       	rjmp	.+32     	; 0x116 <pulse_width+0x74>
		{
			if(TCNT1 > 60000) break; else continue;
  f6:	2c b5       	in	r18, 0x2c	; 44
  f8:	3d b5       	in	r19, 0x2d	; 45
  fa:	21 36       	cpi	r18, 0x61	; 97
  fc:	3a 4e       	sbci	r19, 0xEA	; 234
  fe:	58 f4       	brcc	.+22     	; 0x116 <pulse_width+0x74>
	TCNT1=0x00;        //Again initialising the counter

	//Counting the width of pulse.
	
	//Now wait for the falling edge
	for(i=0;i<600000;i++)
 100:	01 96       	adiw	r24, 0x01	; 1
 102:	a1 1d       	adc	r26, r1
 104:	b1 1d       	adc	r27, r1
 106:	80 3c       	cpi	r24, 0xC0	; 192
 108:	27 e2       	ldi	r18, 0x27	; 39
 10a:	92 07       	cpc	r25, r18
 10c:	29 e0       	ldi	r18, 0x09	; 9
 10e:	a2 07       	cpc	r26, r18
 110:	b1 05       	cpc	r27, r1
 112:	79 f7       	brne	.-34     	; 0xf2 <pulse_width+0x50>
 114:	1b c0       	rjmp	.+54     	; 0x14c <pulse_width+0xaa>
		}
		else
		break;
	}

	if(i==600000)
 116:	80 3c       	cpi	r24, 0xC0	; 192
 118:	97 42       	sbci	r25, 0x27	; 39
 11a:	a9 40       	sbci	r26, 0x09	; 9
 11c:	b1 05       	cpc	r27, r1
 11e:	c9 f0       	breq	.+50     	; 0x152 <pulse_width+0xb0>
	return US_NO_OBSTACLE; //Indicates time out

	//Falling edge found

	result=TCNT1;
 120:	8c b5       	in	r24, 0x2c	; 44
 122:	9d b5       	in	r25, 0x2d	; 45
 124:	a0 e0       	ldi	r26, 0x00	; 0
 126:	b0 e0       	ldi	r27, 0x00	; 0

	//Stop Timer
	TCCR1B=0x00;
 128:	1e bc       	out	0x2e, r1	; 46

	if(result > 60000)
 12a:	81 36       	cpi	r24, 0x61	; 97
 12c:	2a ee       	ldi	r18, 0xEA	; 234
 12e:	92 07       	cpc	r25, r18
 130:	a1 05       	cpc	r26, r1
 132:	b1 05       	cpc	r27, r1
 134:	88 f4       	brcc	.+34     	; 0x158 <pulse_width+0xb6>
	return US_NO_OBSTACLE; //No obstacle
	else
	return (result>>1);
 136:	b6 95       	lsr	r27
 138:	a7 95       	ror	r26
 13a:	97 95       	ror	r25
 13c:	87 95       	ror	r24
 13e:	08 95       	ret
		else
		break;       //High edge detected, so break.
	}

	if(i==600000)
	return US_Time_out;     // No Reply found from US sensor, time lapsed
 140:	84 ef       	ldi	r24, 0xF4	; 244
 142:	9f ef       	ldi	r25, 0xFF	; 255
 144:	08 95       	ret
 146:	84 ef       	ldi	r24, 0xF4	; 244
 148:	9f ef       	ldi	r25, 0xFF	; 255
 14a:	08 95       	ret
		else
		break;
	}

	if(i==600000)
	return US_NO_OBSTACLE; //Indicates time out
 14c:	83 ef       	ldi	r24, 0xF3	; 243
 14e:	9f ef       	ldi	r25, 0xFF	; 255
 150:	08 95       	ret
 152:	83 ef       	ldi	r24, 0xF3	; 243
 154:	9f ef       	ldi	r25, 0xFF	; 255
 156:	08 95       	ret

	//Stop Timer
	TCCR1B=0x00;

	if(result > 60000)
	return US_NO_OBSTACLE; //No obstacle
 158:	83 ef       	ldi	r24, 0xF3	; 243
 15a:	9f ef       	ldi	r25, 0xFF	; 255
	else
	return (result>>1);
 15c:	08 95       	ret

0000015e <int_flag>:
		
	}
	
	
}
void int_flag(int xxx){
 15e:	cf 93       	push	r28
 160:	df 93       	push	r29
 162:	ec e3       	ldi	r30, 0x3C	; 60
 164:	f3 e0       	ldi	r31, 0x03	; 3
 166:	20 91 4e 03 	lds	r18, 0x034E
 16a:	30 91 4f 03 	lds	r19, 0x034F
 16e:	e9 01       	movw	r28, r18
 170:	cc 0f       	add	r28, r28
 172:	dd 1f       	adc	r29, r29
 174:	22 0f       	add	r18, r18
 176:	33 1f       	adc	r19, r19
 178:	22 0f       	add	r18, r18
 17a:	33 1f       	adc	r19, r19
 17c:	22 0f       	add	r18, r18
 17e:	33 1f       	adc	r19, r19
 180:	c2 0f       	add	r28, r18
 182:	d3 1f       	adc	r29, r19
 184:	ce 52       	subi	r28, 0x2E	; 46
 186:	dd 4f       	sbci	r29, 0xFD	; 253
 188:	a0 e9       	ldi	r26, 0x90	; 144
 18a:	b2 e0       	ldi	r27, 0x02	; 2
	int i;
	for(i=0;i<7;i++){
 18c:	20 e0       	ldi	r18, 0x00	; 0
 18e:	30 e0       	ldi	r19, 0x00	; 0
		if(xxx==0){flag[i]=0;}
 190:	00 97       	sbiw	r24, 0x00	; 0
 192:	19 f4       	brne	.+6      	; 0x19a <int_flag+0x3c>
 194:	11 82       	std	Z+1, r1	; 0x01
 196:	10 82       	st	Z, r1
 198:	2a c0       	rjmp	.+84     	; 0x1ee <int_flag+0x90>
		else if(xxx==1){
 19a:	81 30       	cpi	r24, 0x01	; 1
 19c:	91 05       	cpc	r25, r1
 19e:	59 f4       	brne	.+22     	; 0x1b6 <int_flag+0x58>
			if(i<2)flag[i]=0;
 1a0:	22 30       	cpi	r18, 0x02	; 2
 1a2:	31 05       	cpc	r19, r1
 1a4:	1c f4       	brge	.+6      	; 0x1ac <int_flag+0x4e>
 1a6:	11 82       	std	Z+1, r1	; 0x01
 1a8:	10 82       	st	Z, r1
 1aa:	21 c0       	rjmp	.+66     	; 0x1ee <int_flag+0x90>
			else flag[i]=wordlist[lol][i-2];
 1ac:	48 81       	ld	r20, Y
 1ae:	59 81       	ldd	r21, Y+1	; 0x01
 1b0:	51 83       	std	Z+1, r21	; 0x01
 1b2:	40 83       	st	Z, r20
 1b4:	1c c0       	rjmp	.+56     	; 0x1ee <int_flag+0x90>
			}
		else if(xxx==2){flag[i]=flagtemp[0][i];}
 1b6:	82 30       	cpi	r24, 0x02	; 2
 1b8:	91 05       	cpc	r25, r1
 1ba:	31 f4       	brne	.+12     	; 0x1c8 <int_flag+0x6a>
 1bc:	4d 91       	ld	r20, X+
 1be:	5c 91       	ld	r21, X
 1c0:	11 97       	sbiw	r26, 0x01	; 1
 1c2:	51 83       	std	Z+1, r21	; 0x01
 1c4:	40 83       	st	Z, r20
 1c6:	13 c0       	rjmp	.+38     	; 0x1ee <int_flag+0x90>
		else if(xxx==3){flag[i]=flagtemp[1][i];}
 1c8:	83 30       	cpi	r24, 0x03	; 3
 1ca:	91 05       	cpc	r25, r1
 1cc:	39 f4       	brne	.+14     	; 0x1dc <int_flag+0x7e>
 1ce:	1e 96       	adiw	r26, 0x0e	; 14
 1d0:	4d 91       	ld	r20, X+
 1d2:	5c 91       	ld	r21, X
 1d4:	1f 97       	sbiw	r26, 0x0f	; 15
 1d6:	51 83       	std	Z+1, r21	; 0x01
 1d8:	40 83       	st	Z, r20
 1da:	09 c0       	rjmp	.+18     	; 0x1ee <int_flag+0x90>
		else if(xxx==4){flag[i]=flagtemp[2][i];}	
 1dc:	84 30       	cpi	r24, 0x04	; 4
 1de:	91 05       	cpc	r25, r1
 1e0:	31 f4       	brne	.+12     	; 0x1ee <int_flag+0x90>
 1e2:	5c 96       	adiw	r26, 0x1c	; 28
 1e4:	4d 91       	ld	r20, X+
 1e6:	5c 91       	ld	r21, X
 1e8:	5d 97       	sbiw	r26, 0x1d	; 29
 1ea:	51 83       	std	Z+1, r21	; 0x01
 1ec:	40 83       	st	Z, r20
	
	
}
void int_flag(int xxx){
	int i;
	for(i=0;i<7;i++){
 1ee:	2f 5f       	subi	r18, 0xFF	; 255
 1f0:	3f 4f       	sbci	r19, 0xFF	; 255
 1f2:	32 96       	adiw	r30, 0x02	; 2
 1f4:	22 96       	adiw	r28, 0x02	; 2
 1f6:	12 96       	adiw	r26, 0x02	; 2
 1f8:	27 30       	cpi	r18, 0x07	; 7
 1fa:	31 05       	cpc	r19, r1
 1fc:	49 f6       	brne	.-110    	; 0x190 <int_flag+0x32>
			}
		else if(xxx==2){flag[i]=flagtemp[0][i];}
		else if(xxx==3){flag[i]=flagtemp[1][i];}
		else if(xxx==4){flag[i]=flagtemp[2][i];}	
	}	
}
 1fe:	df 91       	pop	r29
 200:	cf 91       	pop	r28
 202:	08 95       	ret

00000204 <checkdemux>:

void checkdemux(int xx)
{
 204:	42 e3       	ldi	r20, 0x32	; 50
 206:	50 e0       	ldi	r21, 0x00	; 0
	int i,j,k,tempAlpha,temp;
	unsigned char column;
	temp=1;
	for (int n=0;n<50;n++){ //to catch eye
		PORTC = (PORTC & 0b11111110)|0b00000010;
		for (int j=0;j<16;j++)
 208:	70 e0       	ldi	r23, 0x00	; 0
 20a:	60 e0       	ldi	r22, 0x00	; 0
{
	int i,j,k,tempAlpha,temp;
	unsigned char column;
	temp=1;
	for (int n=0;n<50;n++){ //to catch eye
		PORTC = (PORTC & 0b11111110)|0b00000010;
 20c:	85 b3       	in	r24, 0x15	; 21
 20e:	8c 7f       	andi	r24, 0xFC	; 252
 210:	82 60       	ori	r24, 0x02	; 2
 212:	85 bb       	out	0x15, r24	; 21
		for (int j=0;j<16;j++)
 214:	87 2f       	mov	r24, r23
 216:	96 2f       	mov	r25, r22
		{
			PORTD=j|(j<<4);
 218:	9c 01       	movw	r18, r24
 21a:	22 95       	swap	r18
 21c:	32 95       	swap	r19
 21e:	30 7f       	andi	r19, 0xF0	; 240
 220:	32 27       	eor	r19, r18
 222:	20 7f       	andi	r18, 0xF0	; 240
 224:	32 27       	eor	r19, r18
 226:	28 2b       	or	r18, r24
 228:	22 bb       	out	0x12, r18	; 18
			temp=0b00001111;
			temp = flag[2];
			temp=ALPHAnew[temp][j%8];
			temp=(temp>>4)&0b00001111;
			if(j<8){PORTA = ALPHAnew[flag[1]][j%8]|(ALPHAnew[flag[2]][j%8]>>4);}
 22a:	88 30       	cpi	r24, 0x08	; 8
 22c:	91 05       	cpc	r25, r1
 22e:	dc f5       	brge	.+118    	; 0x2a6 <checkdemux+0xa2>
 230:	9c 01       	movw	r18, r24
 232:	27 70       	andi	r18, 0x07	; 7
 234:	30 78       	andi	r19, 0x80	; 128
 236:	33 23       	and	r19, r19
 238:	34 f4       	brge	.+12     	; 0x246 <checkdemux+0x42>
 23a:	21 50       	subi	r18, 0x01	; 1
 23c:	31 09       	sbc	r19, r1
 23e:	28 6f       	ori	r18, 0xF8	; 248
 240:	3f 6f       	ori	r19, 0xFF	; 255
 242:	2f 5f       	subi	r18, 0xFF	; 255
 244:	3f 4f       	sbci	r19, 0xFF	; 255
 246:	e0 91 40 03 	lds	r30, 0x0340
 24a:	f0 91 41 03 	lds	r31, 0x0341
 24e:	ee 0f       	add	r30, r30
 250:	ff 1f       	adc	r31, r31
 252:	ee 0f       	add	r30, r30
 254:	ff 1f       	adc	r31, r31
 256:	ee 0f       	add	r30, r30
 258:	ff 1f       	adc	r31, r31
 25a:	e2 0f       	add	r30, r18
 25c:	f3 1f       	adc	r31, r19
 25e:	ee 0f       	add	r30, r30
 260:	ff 1f       	adc	r31, r31
 262:	e0 52       	subi	r30, 0x20	; 32
 264:	ff 4f       	sbci	r31, 0xFF	; 255
 266:	01 90       	ld	r0, Z+
 268:	f0 81       	ld	r31, Z
 26a:	e0 2d       	mov	r30, r0
 26c:	f5 95       	asr	r31
 26e:	e7 95       	ror	r30
 270:	f5 95       	asr	r31
 272:	e7 95       	ror	r30
 274:	f5 95       	asr	r31
 276:	e7 95       	ror	r30
 278:	f5 95       	asr	r31
 27a:	e7 95       	ror	r30
 27c:	a0 91 3e 03 	lds	r26, 0x033E
 280:	b0 91 3f 03 	lds	r27, 0x033F
 284:	aa 0f       	add	r26, r26
 286:	bb 1f       	adc	r27, r27
 288:	aa 0f       	add	r26, r26
 28a:	bb 1f       	adc	r27, r27
 28c:	aa 0f       	add	r26, r26
 28e:	bb 1f       	adc	r27, r27
 290:	2a 0f       	add	r18, r26
 292:	3b 1f       	adc	r19, r27
 294:	d9 01       	movw	r26, r18
 296:	aa 0f       	add	r26, r26
 298:	bb 1f       	adc	r27, r27
 29a:	a0 52       	subi	r26, 0x20	; 32
 29c:	bf 4f       	sbci	r27, 0xFF	; 255
 29e:	2c 91       	ld	r18, X
 2a0:	e2 2b       	or	r30, r18
 2a2:	eb bb       	out	0x1b, r30	; 27
 2a4:	3a c0       	rjmp	.+116    	; 0x31a <checkdemux+0x116>
			else {PORTA = ALPHAnew[flag[3]][j%8]|(ALPHAnew[flag[4]][j%8]>>4);}
 2a6:	9c 01       	movw	r18, r24
 2a8:	27 70       	andi	r18, 0x07	; 7
 2aa:	30 78       	andi	r19, 0x80	; 128
 2ac:	33 23       	and	r19, r19
 2ae:	34 f4       	brge	.+12     	; 0x2bc <checkdemux+0xb8>
 2b0:	21 50       	subi	r18, 0x01	; 1
 2b2:	31 09       	sbc	r19, r1
 2b4:	28 6f       	ori	r18, 0xF8	; 248
 2b6:	3f 6f       	ori	r19, 0xFF	; 255
 2b8:	2f 5f       	subi	r18, 0xFF	; 255
 2ba:	3f 4f       	sbci	r19, 0xFF	; 255
 2bc:	e0 91 44 03 	lds	r30, 0x0344
 2c0:	f0 91 45 03 	lds	r31, 0x0345
 2c4:	ee 0f       	add	r30, r30
 2c6:	ff 1f       	adc	r31, r31
 2c8:	ee 0f       	add	r30, r30
 2ca:	ff 1f       	adc	r31, r31
 2cc:	ee 0f       	add	r30, r30
 2ce:	ff 1f       	adc	r31, r31
 2d0:	e2 0f       	add	r30, r18
 2d2:	f3 1f       	adc	r31, r19
 2d4:	ee 0f       	add	r30, r30
 2d6:	ff 1f       	adc	r31, r31
 2d8:	e0 52       	subi	r30, 0x20	; 32
 2da:	ff 4f       	sbci	r31, 0xFF	; 255
 2dc:	01 90       	ld	r0, Z+
 2de:	f0 81       	ld	r31, Z
 2e0:	e0 2d       	mov	r30, r0
 2e2:	f5 95       	asr	r31
 2e4:	e7 95       	ror	r30
 2e6:	f5 95       	asr	r31
 2e8:	e7 95       	ror	r30
 2ea:	f5 95       	asr	r31
 2ec:	e7 95       	ror	r30
 2ee:	f5 95       	asr	r31
 2f0:	e7 95       	ror	r30
 2f2:	a0 91 42 03 	lds	r26, 0x0342
 2f6:	b0 91 43 03 	lds	r27, 0x0343
 2fa:	aa 0f       	add	r26, r26
 2fc:	bb 1f       	adc	r27, r27
 2fe:	aa 0f       	add	r26, r26
 300:	bb 1f       	adc	r27, r27
 302:	aa 0f       	add	r26, r26
 304:	bb 1f       	adc	r27, r27
 306:	2a 0f       	add	r18, r26
 308:	3b 1f       	adc	r19, r27
 30a:	d9 01       	movw	r26, r18
 30c:	aa 0f       	add	r26, r26
 30e:	bb 1f       	adc	r27, r27
 310:	a0 52       	subi	r26, 0x20	; 32
 312:	bf 4f       	sbci	r27, 0xFF	; 255
 314:	2c 91       	ld	r18, X
 316:	e2 2b       	or	r30, r18
 318:	eb bb       	out	0x1b, r30	; 27
 31a:	28 ec       	ldi	r18, 0xC8	; 200
 31c:	2a 95       	dec	r18
 31e:	f1 f7       	brne	.-4      	; 0x31c <checkdemux+0x118>
	int i,j,k,tempAlpha,temp;
	unsigned char column;
	temp=1;
	for (int n=0;n<50;n++){ //to catch eye
		PORTC = (PORTC & 0b11111110)|0b00000010;
		for (int j=0;j<16;j++)
 320:	01 96       	adiw	r24, 0x01	; 1
 322:	80 31       	cpi	r24, 0x10	; 16
 324:	91 05       	cpc	r25, r1
 326:	09 f0       	breq	.+2      	; 0x32a <checkdemux+0x126>
 328:	77 cf       	rjmp	.-274    	; 0x218 <checkdemux+0x14>
			temp=(temp>>4)&0b00001111;
			if(j<8){PORTA = ALPHAnew[flag[1]][j%8]|(ALPHAnew[flag[2]][j%8]>>4);}
			else {PORTA = ALPHAnew[flag[3]][j%8]|(ALPHAnew[flag[4]][j%8]>>4);}
			_delay_us(600);
		}
		PORTC = (PORTC & 0b11111101)|0b00000001;
 32a:	85 b3       	in	r24, 0x15	; 21
 32c:	8c 7f       	andi	r24, 0xFC	; 252
 32e:	81 60       	ori	r24, 0x01	; 1
 330:	85 bb       	out	0x15, r24	; 21
		for (int j=0;j<16;j++)
 332:	87 2f       	mov	r24, r23
 334:	96 2f       	mov	r25, r22
		{
			PORTD=j|(j<<4);
 336:	9c 01       	movw	r18, r24
 338:	22 95       	swap	r18
 33a:	32 95       	swap	r19
 33c:	30 7f       	andi	r19, 0xF0	; 240
 33e:	32 27       	eor	r19, r18
 340:	20 7f       	andi	r18, 0xF0	; 240
 342:	32 27       	eor	r19, r18
 344:	28 2b       	or	r18, r24
 346:	22 bb       	out	0x12, r18	; 18
			if(j<8){PORTA = ALPHAnew[flag[5]][j%8]|(ALPHAnew[flag[6]][j%8]>>4);}
 348:	88 30       	cpi	r24, 0x08	; 8
 34a:	91 05       	cpc	r25, r1
 34c:	dc f5       	brge	.+118    	; 0x3c4 <checkdemux+0x1c0>
 34e:	9c 01       	movw	r18, r24
 350:	27 70       	andi	r18, 0x07	; 7
 352:	30 78       	andi	r19, 0x80	; 128
 354:	33 23       	and	r19, r19
 356:	34 f4       	brge	.+12     	; 0x364 <checkdemux+0x160>
 358:	21 50       	subi	r18, 0x01	; 1
 35a:	31 09       	sbc	r19, r1
 35c:	28 6f       	ori	r18, 0xF8	; 248
 35e:	3f 6f       	ori	r19, 0xFF	; 255
 360:	2f 5f       	subi	r18, 0xFF	; 255
 362:	3f 4f       	sbci	r19, 0xFF	; 255
 364:	e0 91 48 03 	lds	r30, 0x0348
 368:	f0 91 49 03 	lds	r31, 0x0349
 36c:	ee 0f       	add	r30, r30
 36e:	ff 1f       	adc	r31, r31
 370:	ee 0f       	add	r30, r30
 372:	ff 1f       	adc	r31, r31
 374:	ee 0f       	add	r30, r30
 376:	ff 1f       	adc	r31, r31
 378:	e2 0f       	add	r30, r18
 37a:	f3 1f       	adc	r31, r19
 37c:	ee 0f       	add	r30, r30
 37e:	ff 1f       	adc	r31, r31
 380:	e0 52       	subi	r30, 0x20	; 32
 382:	ff 4f       	sbci	r31, 0xFF	; 255
 384:	01 90       	ld	r0, Z+
 386:	f0 81       	ld	r31, Z
 388:	e0 2d       	mov	r30, r0
 38a:	f5 95       	asr	r31
 38c:	e7 95       	ror	r30
 38e:	f5 95       	asr	r31
 390:	e7 95       	ror	r30
 392:	f5 95       	asr	r31
 394:	e7 95       	ror	r30
 396:	f5 95       	asr	r31
 398:	e7 95       	ror	r30
 39a:	a0 91 46 03 	lds	r26, 0x0346
 39e:	b0 91 47 03 	lds	r27, 0x0347
 3a2:	aa 0f       	add	r26, r26
 3a4:	bb 1f       	adc	r27, r27
 3a6:	aa 0f       	add	r26, r26
 3a8:	bb 1f       	adc	r27, r27
 3aa:	aa 0f       	add	r26, r26
 3ac:	bb 1f       	adc	r27, r27
 3ae:	2a 0f       	add	r18, r26
 3b0:	3b 1f       	adc	r19, r27
 3b2:	d9 01       	movw	r26, r18
 3b4:	aa 0f       	add	r26, r26
 3b6:	bb 1f       	adc	r27, r27
 3b8:	a0 52       	subi	r26, 0x20	; 32
 3ba:	bf 4f       	sbci	r27, 0xFF	; 255
 3bc:	2c 91       	ld	r18, X
 3be:	e2 2b       	or	r30, r18
 3c0:	eb bb       	out	0x1b, r30	; 27
 3c2:	1e c0       	rjmp	.+60     	; 0x400 <checkdemux+0x1fc>
			else {PORTA = hangman4[t1][j%8];}
 3c4:	e0 91 3a 03 	lds	r30, 0x033A
 3c8:	f0 91 3b 03 	lds	r31, 0x033B
 3cc:	9c 01       	movw	r18, r24
 3ce:	27 70       	andi	r18, 0x07	; 7
 3d0:	30 78       	andi	r19, 0x80	; 128
 3d2:	33 23       	and	r19, r19
 3d4:	34 f4       	brge	.+12     	; 0x3e2 <checkdemux+0x1de>
 3d6:	21 50       	subi	r18, 0x01	; 1
 3d8:	31 09       	sbc	r19, r1
 3da:	28 6f       	ori	r18, 0xF8	; 248
 3dc:	3f 6f       	ori	r19, 0xFF	; 255
 3de:	2f 5f       	subi	r18, 0xFF	; 255
 3e0:	3f 4f       	sbci	r19, 0xFF	; 255
 3e2:	ee 0f       	add	r30, r30
 3e4:	ff 1f       	adc	r31, r31
 3e6:	ee 0f       	add	r30, r30
 3e8:	ff 1f       	adc	r31, r31
 3ea:	ee 0f       	add	r30, r30
 3ec:	ff 1f       	adc	r31, r31
 3ee:	2e 0f       	add	r18, r30
 3f0:	3f 1f       	adc	r19, r31
 3f2:	f9 01       	movw	r30, r18
 3f4:	ee 0f       	add	r30, r30
 3f6:	ff 1f       	adc	r31, r31
 3f8:	e0 5a       	subi	r30, 0xA0	; 160
 3fa:	ff 4f       	sbci	r31, 0xFF	; 255
 3fc:	20 81       	ld	r18, Z
 3fe:	2b bb       	out	0x1b, r18	; 27
 400:	26 ea       	ldi	r18, 0xA6	; 166
 402:	2a 95       	dec	r18
 404:	f1 f7       	brne	.-4      	; 0x402 <checkdemux+0x1fe>
 406:	00 c0       	rjmp	.+0      	; 0x408 <checkdemux+0x204>
			if(j<8){PORTA = ALPHAnew[flag[1]][j%8]|(ALPHAnew[flag[2]][j%8]>>4);}
			else {PORTA = ALPHAnew[flag[3]][j%8]|(ALPHAnew[flag[4]][j%8]>>4);}
			_delay_us(600);
		}
		PORTC = (PORTC & 0b11111101)|0b00000001;
		for (int j=0;j<16;j++)
 408:	01 96       	adiw	r24, 0x01	; 1
 40a:	80 31       	cpi	r24, 0x10	; 16
 40c:	91 05       	cpc	r25, r1
 40e:	09 f0       	breq	.+2      	; 0x412 <checkdemux+0x20e>
 410:	92 cf       	rjmp	.-220    	; 0x336 <checkdemux+0x132>
 412:	41 50       	subi	r20, 0x01	; 1
 414:	51 09       	sbc	r21, r1
void checkdemux(int xx)
{
	int i,j,k,tempAlpha,temp;
	unsigned char column;
	temp=1;
	for (int n=0;n<50;n++){ //to catch eye
 416:	41 15       	cp	r20, r1
 418:	51 05       	cpc	r21, r1
 41a:	09 f0       	breq	.+2      	; 0x41e <checkdemux+0x21a>
 41c:	f7 ce       	rjmp	.-530    	; 0x20c <checkdemux+0x8>
			else {PORTA = hangman4[t1][j%8];}
			_delay_us(500);
		}
		
	}
 41e:	08 95       	ret

00000420 <main>:
	int lol;
int main(void)
{
	//int xx;
	//while(1){
	lol=0;
 420:	10 92 4f 03 	sts	0x034F, r1
 424:	10 92 4e 03 	sts	0x034E, r1
	int inc;
	DDRD = 0xFF;//PORTB,C,D are set as output
 428:	cf ef       	ldi	r28, 0xFF	; 255
 42a:	c1 bb       	out	0x11, r28	; 17
	DDRA = 0xFF;
 42c:	ca bb       	out	0x1a, r28	; 26
	DDRC = 0xFF;	
 42e:	c4 bb       	out	0x14, r28	; 20
	uint16_t r;
	US_init();
 430:	0e 94 49 00 	call	0x92	; 0x92 <US_init>
	int distance;
	int distance2;		
	DDRA = 0xff;
 434:	ca bb       	out	0x1a, r28	; 26
	DDRC = 0xff;
 436:	c4 bb       	out	0x14, r28	; 20
	
	while(1){
		
		t1=1;
 438:	33 24       	eor	r3, r3
 43a:	33 94       	inc	r3
 43c:	21 2c       	mov	r2, r1
		int xx=0;
 43e:	d1 2c       	mov	r13, r1
 440:	c1 2c       	mov	r12, r1
					}
				}
			}
			else{
				PORTC= PORTC&0b10111111;
				flag[1]++;
 442:	ce e3       	ldi	r28, 0x3E	; 62
 444:	d3 e0       	ldi	r29, 0x03	; 3
 446:	0a e4       	ldi	r16, 0x4A	; 74
 448:	13 e0       	ldi	r17, 0x03	; 3
		r8=0;
		wr=0;	
		while(1)
		{		
			int xx;
			xx=0;	
 44a:	ed 2c       	mov	r14, r13
 44c:	fc 2c       	mov	r15, r12
 44e:	0f 2e       	mov	r0, r31
 450:	f0 e4       	ldi	r31, 0x40	; 64
 452:	4f 2e       	mov	r4, r31
 454:	f3 e0       	ldi	r31, 0x03	; 3
 456:	5f 2e       	mov	r5, r31
 458:	f0 2d       	mov	r31, r0
				if(flag[1]!=0){
					for(int i=0;i<5;i++){
						if(wordlist[lol][i]==flag[1]){
							if(flag[i+2]==0){
								flag[i+2]=flag[1];
								xx=1;
 45a:	93 2c       	mov	r9, r3
 45c:	82 2c       	mov	r8, r2
			t1=0;
			for(inc=0;inc<9;inc++){
			checkdemux(xx);}
		}
		else if(wr==6){
			t1=6;
 45e:	0f 2e       	mov	r0, r31
 460:	f6 e0       	ldi	r31, 0x06	; 6
 462:	7f 2e       	mov	r7, r31
 464:	f0 2d       	mov	r31, r0
 466:	61 2c       	mov	r6, r1
	DDRA = 0xff;
	DDRC = 0xff;
	
	while(1){
		
		t1=1;
 468:	30 92 3a 03 	sts	0x033A, r3
 46c:	20 92 3b 03 	sts	0x033B, r2
		int xx=0;
 470:	ad 2c       	mov	r10, r13
 472:	bc 2c       	mov	r11, r12
			
		while(1)
		{			
			US_trig();
 474:	0e 94 4b 00 	call	0x96	; 0x96 <US_trig>
			r=pulse_width();
 478:	0e 94 51 00 	call	0xa2	; 0xa2 <pulse_width>
			distance=(r/58);
 47c:	9c 01       	movw	r18, r24
 47e:	af e9       	ldi	r26, 0x9F	; 159
 480:	b6 e4       	ldi	r27, 0x46	; 70
 482:	0e 94 ac 03 	call	0x758	; 0x758 <__umulhisi3>
 486:	92 95       	swap	r25
 488:	82 95       	swap	r24
 48a:	8f 70       	andi	r24, 0x0F	; 15
 48c:	89 27       	eor	r24, r25
 48e:	9f 70       	andi	r25, 0x0F	; 15
 490:	89 27       	eor	r24, r25
			distance2=(r/148);
			
			if(distance >0.1){			
 492:	bc 01       	movw	r22, r24
 494:	88 27       	eor	r24, r24
 496:	77 fd       	sbrc	r23, 7
 498:	80 95       	com	r24
 49a:	98 2f       	mov	r25, r24
 49c:	0e 94 49 03 	call	0x692	; 0x692 <__floatsisf>
 4a0:	2d ec       	ldi	r18, 0xCD	; 205
 4a2:	3c ec       	ldi	r19, 0xCC	; 204
 4a4:	4c ec       	ldi	r20, 0xCC	; 204
 4a6:	5d e3       	ldi	r21, 0x3D	; 61
 4a8:	0e 94 84 03 	call	0x708	; 0x708 <__gesf2>
 4ac:	18 16       	cp	r1, r24
 4ae:	ac f4       	brge	.+42     	; 0x4da <main+0xba>
				if(xx==0){int_flag(2);}
 4b0:	a1 14       	cp	r10, r1
 4b2:	b1 04       	cpc	r11, r1
 4b4:	29 f4       	brne	.+10     	; 0x4c0 <main+0xa0>
 4b6:	82 e0       	ldi	r24, 0x02	; 2
 4b8:	90 e0       	ldi	r25, 0x00	; 0
 4ba:	0e 94 af 00 	call	0x15e	; 0x15e <int_flag>
 4be:	12 c0       	rjmp	.+36     	; 0x4e4 <main+0xc4>
				else{
					xx=0;
					int_flag(0);
 4c0:	8d 2d       	mov	r24, r13
 4c2:	9c 2d       	mov	r25, r12
 4c4:	0e 94 af 00 	call	0x15e	; 0x15e <int_flag>
					xx=1;
				}
			}
			checkdemux(xx);
		}		
		r8=0;
 4c8:	d0 92 4c 03 	sts	0x034C, r13
 4cc:	c0 92 4d 03 	sts	0x034D, r12
		wr=0;	
 4d0:	d0 92 4a 03 	sts	0x034A, r13
 4d4:	c0 92 4b 03 	sts	0x034B, r12
 4d8:	09 c0       	rjmp	.+18     	; 0x4ec <main+0xcc>
					int_flag(0);
					break;
				}
			}
			else{
				if(xx==0){
 4da:	a1 14       	cp	r10, r1
 4dc:	b1 04       	cpc	r11, r1
 4de:	11 f4       	brne	.+4      	; 0x4e4 <main+0xc4>
					xx=1;
 4e0:	a3 2c       	mov	r10, r3
 4e2:	b2 2c       	mov	r11, r2
				}
			}
			checkdemux(xx);
 4e4:	c5 01       	movw	r24, r10
 4e6:	0e 94 02 01 	call	0x204	; 0x204 <checkdemux>
		}		
 4ea:	c4 cf       	rjmp	.-120    	; 0x474 <main+0x54>
		wr=0;	
		while(1)
		{		
			int xx;
			xx=0;	
			US_trig();
 4ec:	0e 94 4b 00 	call	0x96	; 0x96 <US_trig>
			r=pulse_width();
 4f0:	0e 94 51 00 	call	0xa2	; 0xa2 <pulse_width>
			distance=(r/58);
 4f4:	9c 01       	movw	r18, r24
 4f6:	af e9       	ldi	r26, 0x9F	; 159
 4f8:	b6 e4       	ldi	r27, 0x46	; 70
 4fa:	0e 94 ac 03 	call	0x758	; 0x758 <__umulhisi3>
 4fe:	92 95       	swap	r25
 500:	82 95       	swap	r24
 502:	8f 70       	andi	r24, 0x0F	; 15
 504:	89 27       	eor	r24, r25
 506:	9f 70       	andi	r25, 0x0F	; 15
 508:	89 27       	eor	r24, r25
			distance2=(r/148);				
			if(distance >0.1){
 50a:	bc 01       	movw	r22, r24
 50c:	88 27       	eor	r24, r24
 50e:	77 fd       	sbrc	r23, 7
 510:	80 95       	com	r24
 512:	98 2f       	mov	r25, r24
 514:	0e 94 49 03 	call	0x692	; 0x692 <__floatsisf>
 518:	2d ec       	ldi	r18, 0xCD	; 205
 51a:	3c ec       	ldi	r19, 0xCC	; 204
 51c:	4c ec       	ldi	r20, 0xCC	; 204
 51e:	5d e3       	ldi	r21, 0x3D	; 61
 520:	0e 94 84 03 	call	0x708	; 0x708 <__gesf2>
 524:	18 16       	cp	r1, r24
 526:	0c f0       	brlt	.+2      	; 0x52a <main+0x10a>
 528:	51 c0       	rjmp	.+162    	; 0x5cc <main+0x1ac>
				PORTC= PORTC|0b01000000;
 52a:	ae 9a       	sbi	0x15, 6	; 21
				if(flag[1]!=0){
 52c:	88 81       	ld	r24, Y
 52e:	99 81       	ldd	r25, Y+1	; 0x01
 530:	89 2b       	or	r24, r25
 532:	09 f4       	brne	.+2      	; 0x536 <main+0x116>
 534:	54 c0       	rjmp	.+168    	; 0x5de <main+0x1be>
 536:	60 91 4c 03 	lds	r22, 0x034C
 53a:	70 91 4d 03 	lds	r23, 0x034D
 53e:	80 91 4e 03 	lds	r24, 0x034E
 542:	90 91 4f 03 	lds	r25, 0x034F
 546:	9c 01       	movw	r18, r24
 548:	22 0f       	add	r18, r18
 54a:	33 1f       	adc	r19, r19
 54c:	dc 01       	movw	r26, r24
 54e:	aa 0f       	add	r26, r26
 550:	bb 1f       	adc	r27, r27
 552:	aa 0f       	add	r26, r26
 554:	bb 1f       	adc	r27, r27
 556:	aa 0f       	add	r26, r26
 558:	bb 1f       	adc	r27, r27
 55a:	a2 0f       	add	r26, r18
 55c:	b3 1f       	adc	r27, r19
 55e:	aa 52       	subi	r26, 0x2A	; 42
 560:	bd 4f       	sbci	r27, 0xFD	; 253
 562:	f2 01       	movw	r30, r4
					for(int i=0;i<5;i++){
						if(wordlist[lol][i]==flag[1]){
 564:	8e 2d       	mov	r24, r14
 566:	9f 2d       	mov	r25, r15
 568:	2d 91       	ld	r18, X+
 56a:	3d 91       	ld	r19, X+
 56c:	48 81       	ld	r20, Y
 56e:	59 81       	ldd	r21, Y+1	; 0x01
 570:	24 17       	cp	r18, r20
 572:	35 07       	cpc	r19, r21
 574:	51 f4       	brne	.+20     	; 0x58a <main+0x16a>
							if(flag[i+2]==0){
 576:	40 81       	ld	r20, Z
 578:	51 81       	ldd	r21, Z+1	; 0x01
 57a:	45 2b       	or	r20, r21
 57c:	31 f4       	brne	.+12     	; 0x58a <main+0x16a>
								flag[i+2]=flag[1];
 57e:	31 83       	std	Z+1, r19	; 0x01
 580:	20 83       	st	Z, r18
								xx=1;
								r8++;							
 582:	6f 5f       	subi	r22, 0xFF	; 255
 584:	7f 4f       	sbci	r23, 0xFF	; 255
				if(flag[1]!=0){
					for(int i=0;i<5;i++){
						if(wordlist[lol][i]==flag[1]){
							if(flag[i+2]==0){
								flag[i+2]=flag[1];
								xx=1;
 586:	89 2d       	mov	r24, r9
 588:	98 2d       	mov	r25, r8
 58a:	32 96       	adiw	r30, 0x02	; 2
			distance=(r/58);
			distance2=(r/148);				
			if(distance >0.1){
				PORTC= PORTC|0b01000000;
				if(flag[1]!=0){
					for(int i=0;i<5;i++){
 58c:	e0 17       	cp	r30, r16
 58e:	f1 07       	cpc	r31, r17
 590:	59 f7       	brne	.-42     	; 0x568 <main+0x148>
 592:	70 93 4d 03 	sts	0x034D, r23
 596:	60 93 4c 03 	sts	0x034C, r22
								xx=1;
								r8++;							
							}
						}
					}
					flag[1]=0;
 59a:	19 82       	std	Y+1, r1	; 0x01
 59c:	18 82       	st	Y, r1
					if(xx==0){
 59e:	00 97       	sbiw	r24, 0x00	; 0
 5a0:	01 f5       	brne	.+64     	; 0x5e2 <main+0x1c2>
						t1++;
 5a2:	20 91 3a 03 	lds	r18, 0x033A
 5a6:	30 91 3b 03 	lds	r19, 0x033B
 5aa:	2f 5f       	subi	r18, 0xFF	; 255
 5ac:	3f 4f       	sbci	r19, 0xFF	; 255
 5ae:	30 93 3b 03 	sts	0x033B, r19
 5b2:	20 93 3a 03 	sts	0x033A, r18
						wr++;
 5b6:	20 91 4a 03 	lds	r18, 0x034A
 5ba:	30 91 4b 03 	lds	r19, 0x034B
 5be:	2f 5f       	subi	r18, 0xFF	; 255
 5c0:	3f 4f       	sbci	r19, 0xFF	; 255
 5c2:	30 93 4b 03 	sts	0x034B, r19
 5c6:	20 93 4a 03 	sts	0x034A, r18
 5ca:	0b c0       	rjmp	.+22     	; 0x5e2 <main+0x1c2>
					}
				}
			}
			else{
				PORTC= PORTC&0b10111111;
 5cc:	ae 98       	cbi	0x15, 6	; 21
				flag[1]++;
 5ce:	88 81       	ld	r24, Y
 5d0:	99 81       	ldd	r25, Y+1	; 0x01
 5d2:	01 96       	adiw	r24, 0x01	; 1
 5d4:	99 83       	std	Y+1, r25	; 0x01
 5d6:	88 83       	st	Y, r24
		r8=0;
		wr=0;	
		while(1)
		{		
			int xx;
			xx=0;	
 5d8:	8e 2d       	mov	r24, r14
 5da:	9f 2d       	mov	r25, r15
 5dc:	02 c0       	rjmp	.+4      	; 0x5e2 <main+0x1c2>
 5de:	8e 2d       	mov	r24, r14
 5e0:	9f 2d       	mov	r25, r15
			}
			else{
				PORTC= PORTC&0b10111111;
				flag[1]++;
			}
			checkdemux(xx);
 5e2:	0e 94 02 01 	call	0x204	; 0x204 <checkdemux>
			if(r8==5||wr==6){
 5e6:	80 91 4c 03 	lds	r24, 0x034C
 5ea:	90 91 4d 03 	lds	r25, 0x034D
 5ee:	05 97       	sbiw	r24, 0x05	; 5
 5f0:	41 f0       	breq	.+16     	; 0x602 <main+0x1e2>
 5f2:	80 91 4a 03 	lds	r24, 0x034A
 5f6:	90 91 4b 03 	lds	r25, 0x034B
 5fa:	06 97       	sbiw	r24, 0x06	; 6
 5fc:	09 f0       	breq	.+2      	; 0x600 <main+0x1e0>
 5fe:	76 cf       	rjmp	.-276    	; 0x4ec <main+0xcc>
 600:	18 c0       	rjmp	.+48     	; 0x632 <main+0x212>
				break;
			}
		}	
		if(r8==5){
			int_flag(3);
 602:	83 e0       	ldi	r24, 0x03	; 3
 604:	90 e0       	ldi	r25, 0x00	; 0
 606:	0e 94 af 00 	call	0x15e	; 0x15e <int_flag>
			t1=0;
 60a:	d0 92 3a 03 	sts	0x033A, r13
 60e:	c0 92 3b 03 	sts	0x033B, r12
 612:	0f 2e       	mov	r0, r31
 614:	f9 e0       	ldi	r31, 0x09	; 9
 616:	af 2e       	mov	r10, r31
 618:	f0 2d       	mov	r31, r0
 61a:	b1 2c       	mov	r11, r1
			for(inc=0;inc<9;inc++){
			checkdemux(xx);}
 61c:	8d 2d       	mov	r24, r13
 61e:	9c 2d       	mov	r25, r12
 620:	0e 94 02 01 	call	0x204	; 0x204 <checkdemux>
 624:	81 e0       	ldi	r24, 0x01	; 1
 626:	a8 1a       	sub	r10, r24
 628:	b1 08       	sbc	r11, r1
			}
		}	
		if(r8==5){
			int_flag(3);
			t1=0;
			for(inc=0;inc<9;inc++){
 62a:	a1 14       	cp	r10, r1
 62c:	b1 04       	cpc	r11, r1
 62e:	b1 f7       	brne	.-20     	; 0x61c <main+0x1fc>
 630:	24 c0       	rjmp	.+72     	; 0x67a <main+0x25a>
			checkdemux(xx);}
		}
		else if(wr==6){
			t1=6;
 632:	70 92 3a 03 	sts	0x033A, r7
 636:	60 92 3b 03 	sts	0x033B, r6
			int_flag(1);
 63a:	81 e0       	ldi	r24, 0x01	; 1
 63c:	90 e0       	ldi	r25, 0x00	; 0
 63e:	0e 94 af 00 	call	0x15e	; 0x15e <int_flag>
 642:	a7 2c       	mov	r10, r7
 644:	b6 2c       	mov	r11, r6
			for(inc=0;inc<6;inc++){
				checkdemux(xx);
 646:	8d 2d       	mov	r24, r13
 648:	9c 2d       	mov	r25, r12
 64a:	0e 94 02 01 	call	0x204	; 0x204 <checkdemux>
 64e:	81 e0       	ldi	r24, 0x01	; 1
 650:	a8 1a       	sub	r10, r24
 652:	b1 08       	sbc	r11, r1
			checkdemux(xx);}
		}
		else if(wr==6){
			t1=6;
			int_flag(1);
			for(inc=0;inc<6;inc++){
 654:	a1 14       	cp	r10, r1
 656:	b1 04       	cpc	r11, r1
 658:	b1 f7       	brne	.-20     	; 0x646 <main+0x226>
				checkdemux(xx);
			}
			int_flag(4);
 65a:	84 e0       	ldi	r24, 0x04	; 4
 65c:	90 e0       	ldi	r25, 0x00	; 0
 65e:	0e 94 af 00 	call	0x15e	; 0x15e <int_flag>
 662:	a7 2c       	mov	r10, r7
 664:	b6 2c       	mov	r11, r6
			for(inc=0;inc<6;inc++){
				checkdemux(xx);
 666:	8d 2d       	mov	r24, r13
 668:	9c 2d       	mov	r25, r12
 66a:	0e 94 02 01 	call	0x204	; 0x204 <checkdemux>
 66e:	81 e0       	ldi	r24, 0x01	; 1
 670:	a8 1a       	sub	r10, r24
 672:	b1 08       	sbc	r11, r1
			int_flag(1);
			for(inc=0;inc<6;inc++){
				checkdemux(xx);
			}
			int_flag(4);
			for(inc=0;inc<6;inc++){
 674:	a1 14       	cp	r10, r1
 676:	b1 04       	cpc	r11, r1
 678:	b1 f7       	brne	.-20     	; 0x666 <main+0x246>
				checkdemux(xx);
			}
		
		}
		lol++;
 67a:	80 91 4e 03 	lds	r24, 0x034E
 67e:	90 91 4f 03 	lds	r25, 0x034F
 682:	01 96       	adiw	r24, 0x01	; 1
 684:	90 93 4f 03 	sts	0x034F, r25
 688:	80 93 4e 03 	sts	0x034E, r24
		
	}
 68c:	ed ce       	rjmp	.-550    	; 0x468 <main+0x48>

0000068e <__floatunsisf>:
 68e:	e8 94       	clt
 690:	09 c0       	rjmp	.+18     	; 0x6a4 <__floatsisf+0x12>

00000692 <__floatsisf>:
 692:	97 fb       	bst	r25, 7
 694:	3e f4       	brtc	.+14     	; 0x6a4 <__floatsisf+0x12>
 696:	90 95       	com	r25
 698:	80 95       	com	r24
 69a:	70 95       	com	r23
 69c:	61 95       	neg	r22
 69e:	7f 4f       	sbci	r23, 0xFF	; 255
 6a0:	8f 4f       	sbci	r24, 0xFF	; 255
 6a2:	9f 4f       	sbci	r25, 0xFF	; 255
 6a4:	99 23       	and	r25, r25
 6a6:	a9 f0       	breq	.+42     	; 0x6d2 <__floatsisf+0x40>
 6a8:	f9 2f       	mov	r31, r25
 6aa:	96 e9       	ldi	r25, 0x96	; 150
 6ac:	bb 27       	eor	r27, r27
 6ae:	93 95       	inc	r25
 6b0:	f6 95       	lsr	r31
 6b2:	87 95       	ror	r24
 6b4:	77 95       	ror	r23
 6b6:	67 95       	ror	r22
 6b8:	b7 95       	ror	r27
 6ba:	f1 11       	cpse	r31, r1
 6bc:	f8 cf       	rjmp	.-16     	; 0x6ae <__floatsisf+0x1c>
 6be:	fa f4       	brpl	.+62     	; 0x6fe <__floatsisf+0x6c>
 6c0:	bb 0f       	add	r27, r27
 6c2:	11 f4       	brne	.+4      	; 0x6c8 <__floatsisf+0x36>
 6c4:	60 ff       	sbrs	r22, 0
 6c6:	1b c0       	rjmp	.+54     	; 0x6fe <__floatsisf+0x6c>
 6c8:	6f 5f       	subi	r22, 0xFF	; 255
 6ca:	7f 4f       	sbci	r23, 0xFF	; 255
 6cc:	8f 4f       	sbci	r24, 0xFF	; 255
 6ce:	9f 4f       	sbci	r25, 0xFF	; 255
 6d0:	16 c0       	rjmp	.+44     	; 0x6fe <__floatsisf+0x6c>
 6d2:	88 23       	and	r24, r24
 6d4:	11 f0       	breq	.+4      	; 0x6da <__floatsisf+0x48>
 6d6:	96 e9       	ldi	r25, 0x96	; 150
 6d8:	11 c0       	rjmp	.+34     	; 0x6fc <__floatsisf+0x6a>
 6da:	77 23       	and	r23, r23
 6dc:	21 f0       	breq	.+8      	; 0x6e6 <__floatsisf+0x54>
 6de:	9e e8       	ldi	r25, 0x8E	; 142
 6e0:	87 2f       	mov	r24, r23
 6e2:	76 2f       	mov	r23, r22
 6e4:	05 c0       	rjmp	.+10     	; 0x6f0 <__floatsisf+0x5e>
 6e6:	66 23       	and	r22, r22
 6e8:	71 f0       	breq	.+28     	; 0x706 <__floatsisf+0x74>
 6ea:	96 e8       	ldi	r25, 0x86	; 134
 6ec:	86 2f       	mov	r24, r22
 6ee:	70 e0       	ldi	r23, 0x00	; 0
 6f0:	60 e0       	ldi	r22, 0x00	; 0
 6f2:	2a f0       	brmi	.+10     	; 0x6fe <__floatsisf+0x6c>
 6f4:	9a 95       	dec	r25
 6f6:	66 0f       	add	r22, r22
 6f8:	77 1f       	adc	r23, r23
 6fa:	88 1f       	adc	r24, r24
 6fc:	da f7       	brpl	.-10     	; 0x6f4 <__floatsisf+0x62>
 6fe:	88 0f       	add	r24, r24
 700:	96 95       	lsr	r25
 702:	87 95       	ror	r24
 704:	97 f9       	bld	r25, 7
 706:	08 95       	ret

00000708 <__gesf2>:
 708:	03 d0       	rcall	.+6      	; 0x710 <__fp_cmp>
 70a:	08 f4       	brcc	.+2      	; 0x70e <__gesf2+0x6>
 70c:	8f ef       	ldi	r24, 0xFF	; 255
 70e:	08 95       	ret

00000710 <__fp_cmp>:
 710:	99 0f       	add	r25, r25
 712:	00 08       	sbc	r0, r0
 714:	55 0f       	add	r21, r21
 716:	aa 0b       	sbc	r26, r26
 718:	e0 e8       	ldi	r30, 0x80	; 128
 71a:	fe ef       	ldi	r31, 0xFE	; 254
 71c:	16 16       	cp	r1, r22
 71e:	17 06       	cpc	r1, r23
 720:	e8 07       	cpc	r30, r24
 722:	f9 07       	cpc	r31, r25
 724:	c0 f0       	brcs	.+48     	; 0x756 <__fp_cmp+0x46>
 726:	12 16       	cp	r1, r18
 728:	13 06       	cpc	r1, r19
 72a:	e4 07       	cpc	r30, r20
 72c:	f5 07       	cpc	r31, r21
 72e:	98 f0       	brcs	.+38     	; 0x756 <__fp_cmp+0x46>
 730:	62 1b       	sub	r22, r18
 732:	73 0b       	sbc	r23, r19
 734:	84 0b       	sbc	r24, r20
 736:	95 0b       	sbc	r25, r21
 738:	39 f4       	brne	.+14     	; 0x748 <__fp_cmp+0x38>
 73a:	0a 26       	eor	r0, r26
 73c:	61 f0       	breq	.+24     	; 0x756 <__fp_cmp+0x46>
 73e:	23 2b       	or	r18, r19
 740:	24 2b       	or	r18, r20
 742:	25 2b       	or	r18, r21
 744:	21 f4       	brne	.+8      	; 0x74e <__fp_cmp+0x3e>
 746:	08 95       	ret
 748:	0a 26       	eor	r0, r26
 74a:	09 f4       	brne	.+2      	; 0x74e <__fp_cmp+0x3e>
 74c:	a1 40       	sbci	r26, 0x01	; 1
 74e:	a6 95       	lsr	r26
 750:	8f ef       	ldi	r24, 0xFF	; 255
 752:	81 1d       	adc	r24, r1
 754:	81 1d       	adc	r24, r1
 756:	08 95       	ret

00000758 <__umulhisi3>:
 758:	a2 9f       	mul	r26, r18
 75a:	b0 01       	movw	r22, r0
 75c:	b3 9f       	mul	r27, r19
 75e:	c0 01       	movw	r24, r0
 760:	a3 9f       	mul	r26, r19
 762:	70 0d       	add	r23, r0
 764:	81 1d       	adc	r24, r1
 766:	11 24       	eor	r1, r1
 768:	91 1d       	adc	r25, r1
 76a:	b2 9f       	mul	r27, r18
 76c:	70 0d       	add	r23, r0
 76e:	81 1d       	adc	r24, r1
 770:	11 24       	eor	r1, r1
 772:	91 1d       	adc	r25, r1
 774:	08 95       	ret

00000776 <_exit>:
 776:	f8 94       	cli

00000778 <__stop_program>:
 778:	ff cf       	rjmp	.-2      	; 0x778 <__stop_program>
